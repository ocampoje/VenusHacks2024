[{"LectureId":"66524d7dc0ab0d354c539791","LectureName":"Example 1 Lecture","LectureTranscript":"Example 1 Transcript"},{"LectureId":"66524dbcc0ab0d354c539792","LectureName":"Example 2 Lecture","LectureTranscript":"Example 2 Transcript"},{"LectureId":"66524dc7c0ab0d354c539793","LectureName":"Example 3 Lecture","LectureTranscript":"Example 3 Transcript"},{"LectureId":"66524dd1c0ab0d354c539794","LectureName":"Example 4 Lecture","LectureTranscript":"Example 4 Transcript"},{"LectureId":"66526a8ab8db07cbd8fb8632","LectureName":"Example to delete 1","LectureTranscript":"Example 1 Transcript"},{"LectureId":"665288c2022707a8e8c17e53","LectureName":"Test add ui","LectureTranscript":"Some random content"},{"LectureId":"6652a4f969861fe7a63fa081","LectureName":"ICS 32 Lecture 20","LectureTranscript":"t's so quiet today. It's because the last class. OK, so before I start the class, I just wanted to show one thing that I'm going to actually publish to all of you later today, which is a list of movies, if I can only find the list of movies. Yeah, OK, I probably have it here. Yes, so there are a few relevant movies, by the way, that I think that most, if not all, people working in computer sciences, software engineering, almost any strong interest in sciences or mathematics should watch at least, especially in computing, should watch at least almost in their lifetimes. So this is a small list of movies. I normally comment to those movies when I am advising people from the master program. So we normally ask them to watch at least this minimal list of movies, like during while they are doing the first quarter of their master programs. But there are more than just this small list. So I'm going to publish all this big list here that has movies since 1927 that people should watch. All of them are more or less related to computers. And actually, it would be pretty good for you to watch before you actually go into an internship or find a job, because people may comment about those movies. And it would look good to you if at least you had the general culture about computing and the movie industry. So I'm going to add this small page that normally is reserved for master students to our ICS32 page later today. So thanks for reminding me of it. Okie dokie. If I forget, please remind me again. I'm going to add this to our web page. Okie dokie. So welcome to our final lecture of ICS32, Program with Social Libraries. So this is the last lecture of ICS32. The next lecture on programming that you're going to have is going to be ICS33. That I promise, it's going to be harder than ICS32. So make sure to come to the ICS33 lectures. So just a reminder, please, if you haven't done this yet, fill the surveys. So this is essentially three bonus points for you. You just need to enter there and fill the two surveys, the academic probation and attrition, and the AI helper survey. So the AI helper is open to everybody. The academic probation and attrition only makes sense if you also reply to the survey in the beginning of the quarter. Another thing that I would like to ask you to do tomorrow when you come to the lab, and even if you're not planning coming to the lab, please come to the lab tomorrow, even if it's for two minutes, just to say hello and thank you and just thanks the learning assistants and the ALAs, and also the TAs. While the TAs are paid, the ALAs are not paid. So the work that the ALAs are doing is completely voluntary. The ALAs get some credits, like as you're doing a course or doing some research, you get some credits because of you're doing that, like general education credits, but they are not paid. So they are there helping you just because they like helping people. They like some of them, they want actually to go to grad school. So they want to start learning how to teach as well. So they like they want you to be ALAs. So like just thank them. Like if you have two minutes to spare tomorrow, just drop by the lab. Just say thanks that they're going to be I'm certainly certain that they are going to be very happy if you just thank them. And if any of you are interested in becoming ALAs during the next quarters, you can apply to become an ALA. You can just like approach Shannon O'Farrill and just ask her, like, how can I become an ALA? There are more instructions here in this web page. And in particular, if you want to become an ALA in ICS32, I teach normally and I like at least in the next few years, I will be teaching ICS32 always during winters. OK, but I only teach during winters. I could not survive teaching ICS32 several times per year. So if you want to work with me like next year, so next winter, just like drop by my office. Don't write me any mail because the likelihood of that I'm going to reply to a mail is small, but drop by my office. Like I'm normally on my office from eight to six, seven every day. So just drop by my office any day of the week. And then, like, we can talk a little bit. OK, I would be more than happy to have any of you as like an ALA for next winter. Normally, the course doesn't change that much. So this year, the course hasn't changed almost anything like because we wanted to check the effects of the AA helper in the different cohorts. So we had last year cohort, we have your cohort, and we're going to compare like after finals week. How your cohorts did in the WPs and how the last year cohort did in the WPs just to see if the AA helper had an effect like to improve like the quality of the submissions and also the grades of the students. Right. Depending on the results, we are going to like be using the AA helper more or less in the next few quarters. OK. Anyway, so everything that you learned this year, like that all the assignments that you have been solving normally for next year, they are going to be very similar. The only thing that's going to change between this year and next winter. So winter twenty twenty five is going to be how we grade. So we're going to change a little bit to the grading process to streamline a little bit of the grading process. For instance, the labs are going to be hopefully automatically graded for next year. OK. And you're going to be submitting the labs via another system, not the outcomes that automatically grades is more assignments. The big assignments, this is not going to change that much, but the labs should change completely. And you're going to have more labs as well for next year. And we are going to drop more labs as well. So we're going to increase probably five labs. I'm going to add five more labs. And we still keep like eight labs as the mandatory for like grading. But we may we may next year increase the number of mandatory labs. Like we're only going to use eight labs for for giving you a grade. But probably we're going to like request you to submit 15 labs out of the 23 that probably we're going to have next year. OK. Like we need to submit anyway. Otherwise, we're going to lose points. But only eight are going to be considered for the grades. So like if you have 10 in eight of the labs like this year, you're going to have 10 in the lab part of the grades. OK. So this is probably the major change that's going to happen between 2024 and 2025. So if you're doing well and if you're like if you believe in yourself now next year, you can actually do become an LA because like everything is like all the assignments, they are not going to change that much. OK. OK. So just a few comments about a five. So first comments. Some students actually asked me if they had to write test cases for the tequinter part of the code. No, you do not need to write test cases for the graphical user interface. There are ways to test the graphical user interface automatically using mocks. But this is an advanced topic, so we're not covering this. So you don't need to actually write test cases for the tequinter part of the code. However, you need to write test cases almost reaching 100 percent coverage for everything that's not graphical user interface. OK. So for everything that's not graphical user interface, you need to write tests. OK. Good. Any questions about this? OK, I just mentioned this because like some students asked me yesterday and on Tuesday like how can I write a test case for a graphical user interface? How can I click a button? So there are ways to do this, but we're not covering this in this class. OK. And the other reminder, and this is a very, very important reminder. A5 will have no extensions at all. Right. If you get sick, the best thing that you can do, perhaps, like if you get really, really, really sick in A5 is just getting really, really, really sick in the finals. There will be no extensions. You're going to get an incomplete squatter and you need to do the course again next squatter and then they will replace your grades like in summer. OK. So you don't get a fail. But like to access this type of solution, you actually need to be really sick. Like just a fluke will not work for those things. OK. And again, this is a reminder. A5 is just the take home part of your final exam. OK. So A5 is a part of the final exam in a certain sense. OK. So be careful with A5. Even like in the server is working perfectly so far and it will probably work perfectly until Wednesday. If the server dies, like on the day of the deadline of A5, there will be no extension later. OK. Like there is no possibilities for extension in A5. Understood? And that's why I have been begging people to start A5 as early as possible. OK. Good. So A3, A4, A5 are grades. So they are usually not possible again, unless the problem was completely on our side. And especially because, especially in those A's, in those assignments, we are even giving you a piece of, like, of an example of what the autograder does essentially. OK. OK. So when we ask, like when you assignment, so this is assignments of accessory two. So when we go to an assignment there, assignments three, four, four, doesn't matter. Like assignment three, for instance. When we give those small pieces of code, especially when we ask, hey, make sure that this works. So what's the autograder does? The autograder is just like several tens, sometimes hundreds of small pieces of code like this. So testing, like, your assignment in this way more or less, right? So when we ask you, OK, you need, we need to be able to import your DS clients and then just run the DS-client.send without any user, like, interaction. This is what the autograder is going to do, right? If this works, and if, like, your DS-client is returning true or false as required, you should be fine, right? So we're actually giving you a part of the autograder in the assignment prompt, OK? So unless there is something, like, really weird in A3, A4, and A5, in those assignments, no regrades is possible, OK? And especially in those assignments, no regrades are possible when, like, you detect, OK, I made a minor mistake. Can I correct that mistake? And then you regrade by my assignments. The answer for those requests is standard no, unless you're not passing the course. So let's say that you're not passing the course, you're failing completely the course, because your A5 doesn't run, because you forgot to add, like, quotation marks somewhere, right? And then you know where the quotation marks should be added to correct your problem. So when those things happen, then I can regrade your assignment, OK? But those exceptions only are allowed when a student is failing the course because of a mistake like that, OK? So this isn't like next week, just drop by my office and I can I can regrade myself, those things, or even during finals, after finals, OK? Understood? Understood? OK, good. Now, talking about finals, the final, right? So what's going to be the final? So first and most important thing, if you work it, like, if you work it in the assignments yourself, if you work it, if you came to the labs, if you work it in your workout projects, you shouldn't be terribly or even surprised by the final, right? So we're not introducing any concepts in the final, OK? Pay attention, because, like, we may ask questions that, as the best, what was assignment two about? And actually, it's like, although the question seems dumb, sometimes, like, and like last year we had like 10 percent sometimes of students failing questions like that. And that essentially indicates that they shouldn't just work it in the assignment in the last minute and probably copy the few parts here and there, changing things here and there. So the student didn't even remember what it was the assignment about, OK? So and those are useful choice questions, even. So study your assignments like you've completed the assignments, you wrote the assignments. So those questions should be treated for you. OK? All the material that's going to be covered in the final, it was either in one or more of the assignments, inside the assignments, or it was among the lectures, OK? So it was something that was covered in the lecture, right? You will probably see a few new codes, but no new concepts. And most of the code is not going to be new. Most of the code that you're going to see that there will be questions like you need to read a code and then you need to like essentially to like what is the code doing? There is a line missing the code. Can you identify what is the line that's missing the code and stuff like that? So but no concept at all should be new. Like imagine that you could have like a code for us. A socket server that has everything correct, but that code never actually created a socket, right? And creating a socket is one of the options that you can select, right? So that's the type of question that you're going to have. No, good question. You're asking your colleagues asking if it's fully multiple choice. It's not fully multiple choice, but it's mostly multiple choice. You can also have like, here's a piece of code. When this code runs, what's going to be the output? And then you need to type the output, right? Things like that, right? So you actually need to run. You need to be vital. You need to run the code on your head, right? Yes, obviously. Yeah, you need like, yeah, you need to remember what are the labs about, right? You completed the labs. Like it was not mandatory, but like we're not considering the grades, but like in principle, you should have been in all the labs, right? Okay, good. Okay, so perhaps there's another thing. Perhaps you are going to see your own codes in the file. It's more likely that you're not going to see your own codes. It's more likely that you're going to see a piece of code or the code of one of your colleagues. But do not be surprised if you recognize your own codes, right? Because I'm actually using like, I'm going to the silence and the big pieces of code here and there to use as part of questions like, okay, there was this code here for the student. This code has a problem. What's the line where the problem is, right? And perhaps it's going to be your own code. So make sure to actually read also your own codes, like just understand like what you wrote. Okay, again, most questions are going to be multiple choice, not all, but most questions are going to be multiple choice. In the very few questions that may, like, and I cannot guarantee, perhaps some of you are going to get, perhaps, actually, I can almost guarantee that all of you are going to get a few known multiple choice questions. But perhaps some of you are going to be lucky and Thomas is going to pick you like a set of questions that all of them are going to be able to address, right? But like, that's going to be a like, okay, like probably 80 or 9% of the questions are going to be multiple choice and you're going to have like about 10% of the questions that are not going to be multiple. Obviously, as I was just mentioning, it's randomly created so different students will get different questions. And the one important, important, very important thing. It's closed books. Lock-in browser, IP control. So you need to be in class or is in person. The final is in person. There is a very few number of exceptions that I granted for students who are not in the US because they are renewing visas outside the US, right? And they sent me actually the note from the embassy indicating that they are not even in the US. Okay. So in those cases, obviously, I grant an exception. But like in every other case, you need to be here. Okay. So make sure to be here. And you need to sign the attendance sheets of the final as well. Okay. That's a good question. I don't remember. I think it's at 8 a.m. Right. It's written on the first page of the cameras. Let me check. I remember that I wrote there in the beginning of the choir. But I think it's, yeah, it's from 8 to 10 a.m. Thursday. Okay. Oh, yeah. Good question. If you have many DSC accommodations or anything, obviously, you don't need to be here, right? You can be in the DSC room as well. Or if the DSC room is like messy, in those cases, come talk to me like in person and then like we can like perhaps grant you an exception to take it somewhere else. Okay. I think that you. Sorry. No, that's just here. The final is here in the classroom. Okay. Yes. Okay. The final is here. You'll be using your own computer. All of you need to bring computers, not tablets, not cell phones, because sometimes, especially when there is code, doesn't show the code correctly when it's not rendered via a computer. Okay. Make sure to bring a laptop. And if you don't have a laptop, make sure to drop by the library and borrow a laptop. And you can even choose what's the laptop that you're borrowing from the library. Perhaps they even have macametries already. No, they don't. But you can get like M1s, M2s, and you can get x86 computers, like HP computers, and so on. It's good. And you cannot take your final in your... What was the name of the... Apple Vision Pro. I actually had a student come into my office with a Vision Pro. This was fun. Okay. Good. Any other questions about the final? No questions? Okay. Good. If you still have questions about the final, just ask me after class today or like just come to my office during the next few days. Okay. Okey-dokey. Good. And I think that that's it for logistics stuff. So now, for the last topic that we are going to be seeing today... The last topic that we are going to be seeing in ICS32, unfortunately, or fortunately, depending on your opinion on ICS32. So it's going to be dashboards. So essentially, what is a dashboard? A dashboard is essentially a very, very, very simple web application. So you can imagine that probably most of you during the pandemic, you would enter like in the New York Times or whatever other journal to see like the curves of like the contagion and stuff like that. Right. Or you could select perhaps like here in the school. We would normally see every single day how many cases we had, local of COVID. We would perhaps like select a few like... How many cases we had last week to decide if we would teach in person or not the following week. So a dashboard normally is used for what you call decision making. So a dashboard, again, is a very, very simple web application. And normally it's a web application used for some sort of decision making for you to take a decision about something. Right. And that's why normally dashboard are very focused applications. Okay. And again, since they are so focused, normally that's why they're so simple. Anyway, normally they are deployed via web applications. Again, very rarely nowadays they are client server applications. For instance, using Tkinter or something like that. Normally nowadays, if old dashboards may be created using normal client server applications. Most dashboards nowadays are essentially anything that's like was developed in the past 10 years or so. They're going to be web applications. Okay. And there are two important concepts when you create a web app. And like the important concepts that you're going to have like one thing that you call the front end and another thing that's called a back end. So many of you heard about front end and back end and full stack engineers. Right. And you even consider probably getting jobs like that. Right. So essentially what is front end and back end. So here you have been learning client and server applications so far. Like using sockets. Right. So essentially a front end is just the client application normally. And the back end is normally the equivalent of the server part of the application. Okay. So normally when you have a client application and the client is something that's running on a web browser. You normally call it front end. And normally when you have like a server and the server is running via a web server. Normally you call that the back end. Okay. So that's essentially the difference between front end and back end. And one of the things that's like differentiates normally simple client server applications from web applications. Is that you have a mix of languages when we talk about web applications. A normal client server application normally is written always using a single language or at most two different languages. Web applications normally they are created using a wide plethora of different languages. Right. And especially in front end and back end they are normally going to use this joint, this joint sets of languages. Normally front end is going to use HTML, CSS and TypeScript nowadays. Older things are going to use JavaScript or worse things are going to be using JavaScript. So TypeScript if you've never heard about TypeScript. It's like JavaScript but with enforcing types essentially. That's the major difference between TypeScript and JavaScript. And in the back end you're going to be seeing normally Java. Java is like the dominant language in the back end world. C, C++, R, especially if you have web applications that are doing data analysis you're going to be seeing R and Python as well. And normally if you have some sort of database that's used you're going to be using SQL or SQL. In CSS 33 depending on the set of assignments that Alex selects for you you may be seeing a little bit of SQL already. You're going to be learning a little bit of SQL which is a language that's used a lot in database applications. In the back end, more modernly, and this is really bad, people have also been using JavaScript. Especially when they use one thing that's called Node.js. You can use it, it's just much, much, much more unsafe than using plain Java. But people have been using this especially because most people don't know how to write good Java code. They don't know how to write good JavaScript code neither, but JavaScript is easier than Java. So since JavaScript is easier than Java people started writing JavaScript code in the back end as well. And then they created Node.js to actually serve as a simple server for JavaScript applications in the back end. But normally this shouldn't be recommended. JavaScript is a very unsafe language for the back end. Anyway, it's also used. But when you are writing anything that needs to be robust you're going to be writing Java more modern. So there are several frameworks for building dashboards. The most widely known in R are Shiny. Some of you are data science majors. You're going to be seeing R a lot. And certainly you're going to be wanting to create simple dashboards. And you're going to be using Shiny to create dashboards in R. In R and Python you're going to be seeing another framework called H2O Wave. And this, by the way, a company also. That H2O is a company that also hires many ICS students. But actually some. But like many ICS students in the past. Grafana if you're coding Java. And Dash if you're just coding in Python. But the framework that you're going to be seeing today, it's not one of the widely used ones. But it's the simplest one. So it's a framework called Streamlits. And I hope that by the end of the lecture today you're going to see how easy it is for you to create a simple web application in Python using Streamlits. And using Streamlits, in the other frameworks, especially in R, you can write everything in R Shiny. In the other frameworks if you want to do anything that's a little bit more different from what normally you do, you need to write things. You need to go into JavaScript and TypeScript. And a little bit of HTML. Using Streamlits you don't even need to touch the HTML level. You can do everything Python directly and you still have an application that runs inside your browser. And the reason for that is because Streamlits is actually writing the JavaScript and the HTML for you. So you write some Python functions and Streamlits is essentially going to translate. It's going to wrap what you're asking Streamlits to do in HTML and JavaScript essentially. Okay, so let's see one example. And if you have your computers, I would really like you to actually do pip install with Streamlits now. So please, please, just do pip install with Streamlits if you have your computers with you. Has pip install worked? Yep. Good. So after pip install with Streamlits, you can start typing this very, very trivial piece of code here. So the most important line is you need to import Streamlits, obviously. And then you're going to be defining a function that we're going to call runDashboard, okay? And your main code is just going to call your runDashboard function, right? That's it. And inside that function, we're going to do something that's like Tridio, which is just like printing something to the screen. Which is going to be calling the write function, okay, inside the Streamlits module. So you're just going to write a Streamlits.write parenthesis and then a string, like here, emptyICS32Dashboard. Don't try to run this code yet after you type it. It's not going to work if you try. Quick question. Raise your hand if you type in the code. Okay. Okay. Most of you. Good. So what's happening here? So what's happening here? So inside this code. What you're asking Streamlits to do in line 8 is essentially the equivalent of print. Like when you do print, you're going to print something to the terminal, right? Like remember, we had to create a window and add the widgets to the window and all this type of stuff. In Streamlits, you don't even need to do that. You can just write, hey, just like print, you just write, write, use write, right? And this string here is going to be essentially added to our webpage. So what Streamlits is doing for you when you ask Streamlits.write is essentially creating all the front-end code, like HTML, JavaScript, and whatever is necessary, and the back-end code as well to run a server, to run a small web server, to serve your application. So this is very, very simple. When you run this, there is no need for you again to learn JavaScript or HTML, right? Instead of printing something to the terminal, you are essentially creating a webpage and a web server and serving your page. So if to run now, you cannot run with Python alone. You actually need to run with Streamlits. That's going to run Python behind, but like you run like this. You type Streamlits, space, run, space the name of your application.py, right? And when you run this, let me just show it's running. It was example dashboard. So when you run, you're going to see, like it takes like one or two seconds, and then it's going to present you what's the IP address of your server, right? Now you have a simple web server that's deploying your application, okay? If you now just copy and paste this address, and obviously the port as well needs to be there, and then you just enter in a browser, please wait what? Yeah, it took a while. And then you have a simple, very, very trivial web application that's running already, right? So like this web application is almost useless because you're just printing something to the screen, right? But you can do more. You're going to see in a minute how to do more with Streamlits as well. But in any way, you see how easy it is for you instead of printing to the terminal, actually creating a web application that actually prints whatever is the output of your code to a web, to the web, or to a web application. It's pretty easy, right? So it just needs essentially to, instead of using the print in Python, you just use the Streamlits dot write and all. Okay, now how many of you managed to get the web application running? Raise your hand. Okay, a few. You should try this, okay? Just try running the web applications, very simple web application during the weekends, or especially after the quarter is over. Okay, so if you just run this and you access this IP address here, whatever IP address Streamlits is indicating to you that your application is running, you're going to be able to see this run. There are, Streamlits is not only doing what you ask it to do, right? Beyond printing the application, Streamlits comes with other niceties as well. In the same way that this web application is running in a nice white dashboard, you could actually ask and change settings to make it, to change another theme, and to apply, for instance, a dark mode theme. And now your application looks fancier. It looks dark, right? Up to you. You can also define later additional themes if you wish to. And you never have, you never even have to write a single line of code to be able to actually reconfigure the look and feel of your application, right? Much easier than tick-inter, right? And, obviously, this is a web application, not a local GUI. Okay, so, and you get those things for free. So, obviously, just printing things without any formatting would not help. Normally, to do formatting in, like, a web context, you will need to learn a little bit of HTML or CSS. Since Streamlits is trying to make things easier for the programmer, it actually uses another language that's much simpler than HTML and CSS to configure how things look in the screen and how, like, you can type things in the screen. And this language is called Markdown. So, let's see one simple example here. So, here, if you add, like, a dash, like, Streamlits dot write, and then dash, and then the text, this is essentially indicating that you want this to be a heading. So, if you are using a heading, the font will be rendered larger in the page. So, if you just write this simple application, you're going to get, like, a web page that looks like this, an application that's going to look like this when it's running. So, ICS32 customized dashboard. So, this language, again, it's called Markdown. So, it's not a very complex language. It's just, like, a few sets of, like, strings that you can add to your string to indicate how your string is going to look like in the screen when it's rendered, okay? So, for the entire guide, you can just go to this web page. But, like, for most applications, the basic usage of Markdown will come to those symbols only. So, you're going to be using the hash if you're just wanting to create a heading in the text. If you use asterisk, asterisk, and then you type the text, asterisk, asterisk, the text is going to become bold. If you just use one asterisk, the text is going to become italic. If you use the greater signal, you're going to get a quote, like, it's going to be inside the quotation marks. If you use minus, you're going to get, like, a list. You're going to be creating a list of items. And if you add, like, if you write the text and then a link in parentheses just after the text, you're going to actually create an HTML link. So, like, this very simple example here is going to render a page that's going to look like this, right? You're going to have the heading with the dash, with the hash code. Then you can have, like, just normal text. If you add the greater signal, you're going to get, like, a quotation mark, like a quote. And you can create lists, like I said, 31, 32, 33, if you just put the minus signs. And you can create a properly linked text if you just add the link in parentheses after the text inside brackets. And then you have, like... So you write HTML without knowing HTML, right? So you can actually start creating, like, web pages that are even fancy looking just by using Streamlits, like this, directly from Python, okay? Okay, only using text, it, like, works, but I bet that most of you would like also to add images, right? How you can add an image to a web page using Streamlits. You just write image. Like, you use Streamlits.image, and then you add the link to the image that you produced, like, either a JPEG or PNG or whatever, and you set the size of the image as well. This very small example will render a page that's going to look like this. I set 32 example text and image formatting, and then, like, the logo of the universe of California, right? Because this image, this UCI underscore logo, the JPEG, is essentially the logo of the universe of California, okay? Okay, beyond adding simple images, you can also add tables, and tables are interactive. So let's say that you have, like, a simple, funded data frame. You learn, we learned Pundus a week and a half ago or two weeks ago. You have a simple data frame, like in Pundus. If you write the Pundus data frame directly, like, if you just use write and then you pass a Pundus data frame as the argument, you are going to get a nice-looking and interactive table rendered to your application, right? And then you can just show, like, whatever, quotation the stock market and whatever, like the price of the Bitcoins, whatever you're interested in, okay? So this is also very simple to do. You just need, again, to call write, okay? So again, when you want to add an image, you use image, when you want to add other stuff, and you're going to see even an image, an interactive image, you use write, okay? So remember plotly, hopefully all of you remember, and hopefully you use either plotly or mathplotly in WP4, right? Which was essentially a free point, WP4, right? So this was the code that we wrote in our lecture, I don't remember which lecture, lecture 9 or lecture 10, like, a while ago, to create a plot of those, a graph of those two lines, right? And here, plotly would create you an HTML object, right? And your code just published this HTML object to the web, and it was interactive, right? However, this was not an application, just one visualization. Using Streamlits, you can actually create a lot of, like, those graphs and add those graphs inside your application, right? And the code itself, it essentially unchanged. So this is the entire code that we wrote in the previous lecture. And in line 19 here, we were asking... Whoa, okay, it's back, yeah, okay, it's back. So in line 19 here, we were asking plotly to create an HTML file. If instead of creating the HTML file, we would ask plotly to return the figure itself. So now you have the figure that's like a plotly object. And Streamlits understands plotly objects. So you can just write a very simple web application in Streamlits. So this is our web application, okay? So we have, like, you're going to add the UCI logo on the top, write some text, and then we're going just to pass as the argument of the write one plotly figure, okay? So this is a plotly object, essentially. And then you have your figure rendered inside your nice-looking dashboard application. Like, for free. Like, you already learned plotly. You already learned metplotly. You can just take what you learned, like, four weeks ago and add inside what you're learning now, and you can create a simple web application using that, right? And this is fully interactive, right? You can actually go there, zoom in, zoom out, select stuff, and so on. Another widely useful element that you can use in Streamlits is called metric. So here we are going to use this metric, which is going to look like a number with another number on the bottom to indicate if the big number is going up or down. And you could imagine that this could indicate temperatures. This could indicate, like, you have a value for the stock, and if the stock is going up or down now, you could indicate, like, your bank accounts. If your bank accounts are going up or down, depending if you went to party last weekend or not, and so on, right? So you can write very simple web applications using metrics to keep track of those things. So here in this application, we are creating two columns in the page. So now we're dividing. So we write a few stuff on the top, and then we divide the application in two columns. So if the Streamlits dot columns, and we pass the number two, we're just saying, hey, now we're going to have two columns to add stuff to. And then we'll say, hey, in column one, please add the metric temperature. And here, like, since I only understand Celsius, I'm writing 23 degrees Celsius and 1.2 degrees Celsius. And we're going to see that since this number is positive, this will indicate a narrow up, okay? And then in the column two, we're going to add another metric that's going to be the humidity. And the humidity will indicate 73%, and since this is minus three, this is going to be indicating that the number is going down, okay? So if you just run this very simple Streamlits application, you are going to have an application that's going to look like this. So you have the text that we ask it to be rendered, and then you have, like, the temperature and the humidity and the actual value of the temperature and humidity and the indication if it's going up or if it's going down, right? And so on. So Streamlits has many of those small things that you can actually use to create your simple web applications, and it supports natively, plotly objects, matplotly objects, bokeh, PyDeck, Graphese, Altair, Vaga, which are all graphing applications for Python, okay? It also comes with a set of plots that barely anyone uses, but it comes, like, if you integrate only bar charts or line charts or area charts, you can just call Streamlits directly to create the application for you, okay? But in principle, almost nobody uses those things, because plotly and matplotly are so, like, useful and, like, the plotters so good that most people are going to mix Streamlits with plotly or matplotly, especially, okay? Anyway, we have been seeing now how to write text to the screen and how to add graphs, even interactive graphs to the screen, right? But as you have been seeing, you also need to take information from the user, right? So in normal Python, you just use inputs. Have you been working in A5 already? Yes, all of you? Please say yes. Yes, okay, good. Make me happy, okay. So in A5 and, like, using Tkinter, you have, like, those text widget box that people can add text, and then you can grab the text, right? You need to have some form of user input of data, right? So even in very simple applications, data input is still normally necessary, right? So how can you do some data input in Streamlits? So in Streamlits comes with all the bells and whistles just like Tkinter, right? You're going to have, like, buttons, track boxes, select boxes, like sliders, like a thing that you can, like, just slide for different values. It comes with, like, inputs, like you can either restrict to pure text or only to numbers. You can have, like, large text areas just like our text editor that we saw, like, in class, right? And it also comes with, like, a few widgets that are normally used in the web context, right? So you can actually create, like, things to do a file upload to the server, to download files from the server, to create a camera input, and then to use the camera feed inside the web application, and so on and so on, right? So let's see, for instance, how you can use a simple button in Streamlits. So to use a very simple button, and this is, like, there are ways to create several buttons in Streamlits applications, and to do that, you need to do exactly what you are doing in Tkinter to create buttons and link those buttons to callback functions that are going to be executed when the user clicks that button, okay? So it's very similar to what you are already doing in Tkinter. But if you're using only one single button, it's even easier, right? So if you're using only one single button, you can just write after it creates the button, you can create a NIF condition, and then if the button state, like, and the button state will be true if the buttons press it, then the code is going to run line 52 and line 53. So in line 52, you are essentially generating a new plot, whatever the plot. You're not seeing the function that's going to generate that plot, right? And after generating that plot, the result of that plot is going to be stored in this figure variable, okay? So this fig string here is indicating a variable that essentially maps and is stored in the session state. So this, you can also create like a simple variable with fig equal to generate plot as well. But you want to preserve that variable between different redraws of the screen. So you want that to be something that's, like, stored in the session state. While this user is logged into the application, this variable will contain the result of generated plot, okay? If the user closes the web app and starts a new web app, you're going to have a new session, okay? So, and to do this, you just call stream lead dot session, the stream lead dot session underscore state, and you pass the name of whatever variable you want to create. Then in line 53, what we are doing is just asking, hey, stream lead, write whatever figure was created to the screen, right? And then you're going to get the value of that variable by calling stream lead dot session state because you're asking, please give me from this session state what's the value of the figure, right? Yeah. So this application here is essentially lecture 13. So all those lines, this looks like a big application, but all those lines, they come directly from lecture 13. That's the application that's going to generate those random walkers, like on the screen, right? We were using, we were seeing this in Matplotlib, right? We would create a figure with random walkers going up or down that looked like stock market, right? The value of stocks in the stock market. So if you want to transform our lecture 13, like, code in a web application with a button that the user can click, you just need to write that small piece of code, which is the same small piece of code that we're seeing here. And then when the user clicks the button, then the generate plot function is going to run, which is our lecture 13 code, right? Again, this is exactly the lecture 13 code, okay? No changes at all. Then if you try to access, if you run this application using stream leads and then you try to access the IP address of your server, you're going to see this web app here. And then if you click the generate walkers button, the application will run, and then you're going to render to the screen those random walkers. Obviously, if you click it again, every time that you click and then the button state becomes true, those two lines of code are going to run again. So you're going to generate new random walkers, save in the session states, and then write this to the screen again. And then the screen is going to be redrawn, essentially, right? And then how many times you write, you're going to get, how many times you click, you can get different random walkers and so on and so on. Every single time you click, you will get different random walkers. Yeah, okay. The entire application is executed in this case, okay? Another and final, I promise that this is going to be the final widget that I'm going to show to you, because this is a very useful widget as well. So the final widget that we're going to see is called the text input. So the text input widget is just like a region where the user can type some text, right? And then, like, in line 12 here, we are creating, like, a text input and grabbing whatever the user types into this variable that is going to be a string called text content, okay? After we get the text content from the user, what we are doing in line 13 now is we are adding a button, and this button is going to be called post. So if you wrote your A3 or your A4, like, in a way that the autograder works and the autograder is going to work well, this application that we are seeing here should work and should give you, essentially, a graphical user interface for you to post messages to the server in a web app, in a simple web app, right? So this button state here, when the button state is going to be true, then we are going to call the DS client that we are importing and calling the method send, and passing, like, the address. In this case, I'm just running the localhost. You should just replace this by the ICS32 distributed server IP address and the port, and then your user name, and then the user password, and then whatever text, the post message that you want to send to the server. If you run this, the application, now you're going to see a web page that's going to look like this. Now the user can type a very simple message here inside this text box, right? And then the user can click post. If the user clicks post, the message should appear in the web server, in our ICS32 distributed server, right? Here, what we are seeing, what you are seeing now here, I'm running a light version of the server. Actually, the light version is the version that we use to grade, right? We just run for each assignment that's being graded. We started a new server, and then we use the IP address and the ports for that server to actually check if the messages are being posted or not correctly, okay? So what you are seeing here is that after the user clicked post, so the client connected, the client joined, then everything was okay, and then the client sends a message with the correct token and with, like, a message to see if the message works. So this is the message that will send to the server, though. So the message arrives correctly in the server side, though. So with, like, you see how easy it is? With 19 lines of code, you actually wrote a GraphQL user interface for a simple version of your A3. To create a better version of your A3, you should also configure, like, the username, the password, and the bio, and, like, those things, right? But you can see that it's not much harder to do. After you can do one, you can actually do multiple of those, right? So you can actually create, like, a pretty nice looking GraphQL user interface for you to actually configure your A3 and actually to start posting stuff to the web, like, afterwards, okay? Okay, Barry, just before coming, I'm probably going to mention a little bit about this, like, in a few minutes, but this is so easy, but if you work really, like, if you dedicate yourself, like, a week, you can probably create a pretty nice looking GraphQL user interface for your A5. And this is not going to be covered in the course, right? And you could be doing something like that during your summer. Don't try to do that during the spring because your spring is going to be, like, very heavy with ICS 33, hopefully, all of you here. Like, but during your summer, you could pick whatever you learned so far, including stream lead, and, like, you can... The server is going to be online during the entire year, like the ICS 32 server, and you can actually create a simple web application that's customized for you to create your own Discord-like person-to-person messenger, right? And if you do this, you should add this to your CV because, like, later, in a few... ICS 31, 32, 33 assignments when you apply to a job interview. Like, nobody should care, at least. But people should care about your own projects. And this would be your own projects, right? Like, this, like, creating a simple, like, application that is, like, Discord but from scratch, which is yours, right? This is your project. And then you can just, like, go into Amazon, create a simple, like, free-tier server and deploy your application running there, and you add the link to your application to your CV, and then people perhaps checking your CVs, they can click in that link and see that you actually do stuff. And then when you get invited for an interview, you can start commenting how you did the application, how the application works, and so on and so on, right? So you can actually demonstrate that you actually know your stuff, right? This is much better than they asking you random questions, right? It's good for you when you call the attention from the interviewer about something that you did because then you can control your interview, right? Otherwise, the interviewer will be controlling your interview and normally putting you in, like, conditions that are perhaps not favorable for you, right? So, like, make sure to create your own projects, especially during summer, okay? And now you're just wanting a big template. Okay, good. So, it's streamlits and dashboards. So this is a very, very simple, like, overview of things that you can do in streamlits, right? To do more advanced stuff in streamlits, you need actually to study a little bit more and do a little bit more. But it's going to, like, after you learn Tkinter, you're going to see that there are a lot of things that are very similar, a lot of concepts that are going to be very similar to Tkinter, okay? So you're going to be able to, like, configure the screen, by setting layouts, like, creating sidebars, dividing the screen columns, using tabs, containers that are going to look like the Tkinter frames. So a container is going to look like when you create a Tkinter frame, you add stuff to that frame, right? And then you put the frame on the screen, right? A container is going to be very similar. You're going to be adding stuff to the streamlits container, and then that container is going to be rendered to the screen. Another thing that you need to learn a little bit more is how to control the state of the application. And in particular, in particular, about the state of the application, you need actually to start, again, very similar to Tkinter, you need to deal with, like, callback functions, right? So each button, each thing that could happen in the application will be linked to a callback function, and then that callback function, when it runs, what are the variables that's going to change? If the variables are, like, application variables, if the variables are states of the application at a certain moment, as we saw the graphs, or if the variables are shared between multiple users of the application, and so on and so on. One important thing that you will need to learn, if you want to do anything serious with Tkinter, is to create caches. Not with Tkinter, with streamlits, because it wants a cache. Essentially, if you have a costly function, if you have a function that takes several seconds to run, or if you have an API call, like, you need to query the remote API to get data for your application to run. This takes, perhaps, some seconds. You don't want to rerun this every single time that something happens in the application, right? Every single time that the user clicks a button, right? You want to store this value, those values, between different runs of the application, between different redrawings of the screen, right? This is what we call a cache. We need to create caches that are going to store the values of variables between different runs of the application. And again, as I was mentioning, during summer, this is a project that you really should do, because this is not a very hard project. This is just hard work. You will not need to think too much. You need to dedicate a lot of yourself to actually do the work, but there's nothing much more challenging than you saw in 32, right? And you're going to be much more challenging stuff in 33, right? And you can already create something that's going to be essentially discord, right? By your own, on your own, right? You don't need anybody. If you wish, as I was mentioning, you can use the server. You can use the ICS32 distributed server if you don't want to write your own server. But it shouldn't be very hard for you, neither, during summer, to actually write your own ICS32-distributed, like, .com, like server, right? You learn, like, how to create the server as well. Like, we saw in class in their assignment tour about the client side, but we saw in class how to create the client and the server, right? So you can just do the same thing that you're doing for the client. You can think a little bit how you can actually use the server side now that you saw in class to actually receive those messages that you were sending previously, right? It's just the other way, right? So in your assignments, you're sending the messages inside the JSON, like, string, right? Now you're receiving those JSON payloads, and you need to open the JSON payloads to do something, right? So, again, you can do the server, like, if you just work hard. Again, there's not going to be much more than what you saw in class. Probably almost all the lines of code, except for the database part, we already saw in class, okay? Okay, now just to finalize the ICS32 course. So what was the ICS32 course, right? So now that's, like, since this is, like, the last five, ten minutes of our class. So the idea, then, of the ICS32 course, if you go back in the beginning of the quarter and remember our first week of lectures, was essentially for all of you to understand why libraries are important, like, why modules, especially, are important in programming, especially in programming Python, right? And how you can use some of those libraries to address more complex problems than the 15, 10 lines of code that you are writing in ICS31, right? The other objective of ICS32 was for you, actually, to get to know some of the most widely used Python libraries that you are going to be using, like, along your lifetime in ICS and also along your lifetime in the industry. Like, for instance, everybody knows Matplotlib. If you try to find a job in data analysis or, like, in software engineering, mix it with, like, data analytics, and you never heard of Matplotlib or Protely, you're not going to pass the first round of the interview, right? So there are a few things that you saw here in this course that are, like, the basics and the fundamentals for you to even be considered to get a job or to get, like, an internship somewhere, right? But, then, like, those two things are, like, the most, perhaps, the most, like, instrumental parts. In my opinion, the most important reason why ICS32 exists is that it is, in ICS32, it's the first time that most of you, not all of you, but most of the vast majority of you, are not coding, like, 15, 20 lines of code. It's the first time that you are actually thinking about building a problem and building, like, a large problem that's going to be able to do more stuff than just solving a small little thing, right? Or a small little challenge. You're now creating, now you have knowledge to actually create problems, right? Like, you're A5. You can be proud of your A5 when you finish A5. You're going to be creating a graphical user interface that's going to be sending messages, just like WhatsApp, right? That you're going to be sending messages to your colleagues, right? Hopefully, all of you are going to succeed next week of, like, actually making this, like, a reality thing, right? I already see that some students are already doing this. We even had, like, a few submissions already in common, so hopefully you are going to get A5 done by the end of next week. In any case, it's an ICS32. Like, ICS32 is that moment where you move from being, like, okay, I heard about coding. It seems fun from, okay, now I see what coding really is, and I agree that it's fun, right? And I want to do this for the rest of my career, or, like, because, like, an ICS32 is just going to be harder, right? So, like, this ICS32 is the moment where you grow up essentially, right? So I hope that you enjoyed, like, doing those things, like, doing those assignments. Sometimes the deadlines are too short, but that's, like, what a 10-week course is, right? 10 weeks to grow up is, like, super fast. It is, I know. But anyway, you have been learning, like, lots and lots of things that, like, many people who are self-taught, like, many people are just, like, learning themselves in the YouTube videos and stuff like that. They will probably never learn until they go to a job interview and then they don't get the job interview, and then they need to learn and come back and learn again and learn again and again. And some people never learn, actually. They manage to get small jobs here and there, but they actually never learn how to code properly, right? So this is one of the great things of the ICS30 series. Like, in ICS31, 32, 33, you learn. Like, in 31, you learn, like, the most basic fundamentals of, like, what is a for loop? What's a variable, right? In ICS32, you are starting to, like, you learn the words in ICS32, in 31. In ICS32, you learn how to build phrases, how to write paragraphs, and how to write chapters of a book. Like, if you work hard, you can even write your own book entirely, right? In ICS33, you will be able to write books and start judging books by other people, as well, right? So that's how, like, the three courses are in training, right? So, like, hopefully, when you leave ICS33, hopefully, again, in July, like, in the end of June, you are going to learn almost every basics that there is to learn about single programming, okay? Anyway, the course enters, then, three primary questions. What is a software library? Hopefully, all of you know what's a software library, or modules in Python, right? How you can use some of the widely known Python libraries, and how to build large software by leveraging the power of, like, multiple software libraries. Like, you saw today, for instance, like, after you learn Matplotlib and Protely, and after you learn Streamlits, you can actually create graphical user applications on the web that are, like, web apps, that if you're smart, you can probably even start making money out of them, right? Like, you can already start making things that you can even sell, who knows? Anyway, the topics that we covered, and I know that you're going to see, like, a big slide now, and this slide I normally keep as reference for the students. I'm not going to read all the things that we covered during the course, but it's good for you to realize how much topics were covered in 10 weeks in your head. Like, all of you are super brave, like, to have survived until this week, and especially to have survived, hopefully, by the end of next week, right? So we saw in this course lots of different software engineering concepts, and this goes, like, requirement tests, unit tests. Like, these are not simple things, right? So you have been seeing all those things during the quarter, right? Even programming, even, like, when you're doing, like, tick-inter, like, there's an event that happened. This is already an advanced topic. There are entire books written by this. There were conferences dedicated to even programming in the past, right? And, like, you saw how to use those things, perhaps, and you have, like, an idea already, right? Higher-order functions. So we saw AMPASA, so very quickly, like, higher-order functions. You even exercised higher-order functions in your WP3. You're probably going to be seeing much more about this in ICS 33. Higher-order functions are pretty advanced concepts in programming. They are fundamental to one type of programming that you're going to learn in the future called functional programming, right? Like, normally, most people in the industry, like in most, like, at least early people in the industry when they're starting their careers, they only know how to do object-oriented programming. Some of them know a little bit of structured programming, but very few know about functional programming. And you already started learning a little bit about functional programming, although I haven't been telling you, like, you're doing functional programming, you're doing functional programming, because Python is a better language to the functional program, but you're already doing a little bit of that with lambdas, with, like, those higher-order functions, with map, okay? Anyway, and, like, again, about a little bit more about soft engineering, you have been, like, forced to do to have your code under source control, right? Since the beginning of the quarter, you have been using Git. In this course, and in ICS 33 as well, you are only going to be using Git locally for your own purposes. Like, in future ICS courses, you are going to be using Git to collaborate with other students, right? You are going to be developing codes that are going to be collaborative between you and other students. If someday, and I hope to see some of you a few years from now, like, one or two years, normally two years from now, in my upper-div courses, you take, like, for instance, the search engine courses that we build the search engine. So two of the major assignments of that course are going to be on, are going to be group projects. And all of you are going to be using Git, not, like, for you all alone, but to collaborate between your team members, right? So when you already started seeing how to use Git now, again, you have been using and learning several software engineering tools that are widely used in the industry. Like, you saw Git. We saw static analysis tools, like PyCode style, Pilings, and we have been talking a lot about testing, and this is, like, a requirement on your A4 and your A5, right, to have a certain test coverage of your assignments, right? Now, this is going to be always standard when you go to work in the industry later on, right? We obviously saw, as this is, like, the software programming libraries course, several models, again, the models that are most important models from the Python standard library, but not only the Python standard library models. You also saw several models that are standard in data science and software engineering all around, right? Like Matplotlib, Protely, NumPy, Pandas, and now Streamlits, okay? We saw different coding concepts and design concepts. We talked about modules. We talked about namespaces. We saw client-user, local client-user applications, remote client-user applications. Today we saw web client-user applications, or, like, front-end and back-end development. You saw something that normally it's never covered in Python-ness Python courses, but that's going to make a promise. That's going to make the life of you much easier when you go to C courses. So if you tried, actually, to do WP1 and WP2 using, like, the FiO6 and FiO reads, so we are talking about here, like, there's not really a file pointer, but the ID is more or less similar to what you're going to be seeing when you go to C and you start talking about memory pointers and file pointers. We were essentially using a file as, like, the memory of the computer, and then we had, like, this pointer that would point to the position of the memory of the file, right, to actually solve your WP1 and your WP2 without using a lot of memory, just, like, moving the read pointer in different positions to the file, right? So this is something that's almost never seen in Python courses, essentially never seen, because this is a concept that Python actually tries to hide from you. Like, Python tries to make programming simple in a way that, like, harms the minds of people who only program in Python because you actually never learned how your code is working, how your variable is allocated to the memory of the computer, right? So this is extremely important when you're thinking about C programming, and you will be forced to think about C programming in the future. Like, it's not going to be an option. You need to pay the C course a few questions from now, okay? And, like, last class we saw also stack data structures. So you will be taking stack courses in the future. Sorry, algorithm data analysis courses in the future. And, like, the simplest, one of the very simplest linear data structures that are out there are the stacks that you saw last class, okay, and that are fundamental for your WP5. So for whoever is trying to do WP5, like, you are already exercising something that you are going to be doing a lot more in 4.6 and, like, 161 in the future course that you will take here in ICS, hopefully with Schindler. So, anyway, but more importantly, again, just to repeat myself, this course, and, like, what you're learning in this course, is not, like, just, like, how to do stuff, but why you're doing stuff, and, like, how to think in codes, how you can think in codes, that will allow you to grow from small pieces of code that are going to solve very small things into large pieces of code that are going to allow you to solve big problems, right? And this is extremely important when you are looking for a job, by the way. If your job description, okay, if you just need money, you are going to take any job, right? But if your job description, if you can choose your job, and hopefully here in the University of California, you are going to be not only, like, solving something that somebody wrote to you. Hey, here are the requirements. Here's a list of requirements. You need to implement this, this, this, so the input is going to be this, and the output is going to be that, right? And you're going to have, like, a bunch of requirements to transform into Python code or Java code or whatever, right? So, hopefully, you're not going to be doing all of that, but you're going to be able, and this is another thing that we tried to pass to you in this course. You're going to be able to extract the requirements, think about, okay, this is the problem that I need to solve. What are the requirements? So what do I need to transform into code to make this change in the world that I wanted to make, right? And remember, like, a large part of the Internet was built here, and, like, I expect nothing from you, like, in the future, like 20 years from now or 10 years from now. I would be very proud if I could see, like, at least one of you actually managed to get, like, to push the world forward. But, actually, most of you will be pushing somehow the world forward a little bit, okay? So with that, I would like to conclude. So, again, you can be proud of the code quality that you are doing so far. Like, if you yourself, like, I am seeing the code quality that you have been generating and comparing what you wrote in A1, P2, A1, P1. We thought you were writing now. I can see how much most of you, not all, but, like, most of you and most of the code grew during the quarter, right? And I really, really hope that, like, all of you, like, are going to be able to produce really great codes in the future. So thank you very much for your patience. I would like to thank a lot, all of you, for your patience. You had to have patience with me during this quarter, right? So good luck in your final. Congratulations, again, on the level of most of your codes. And I'm going to be seeing you around campus and certainly next week for the final exam, okay? So see you next week, then. Thank you. Hello. Yep. Yeah, so it should go back. If it hadn't, like, just go to the TA again and it's like, yeah. Because, like, what's happened is that... So the TA..."},{"LectureId":"6652a66769861fe7a63fa0cc","LectureName":"ICS 32 Lecture 4","LectureTranscript":"Okay, people, good morning. Welcome to another lecture of programming software libraries. So before starting the lecture, just to let you know that I'm quite happy today because like 90% of people submitted on time, assignment 1P2, which is like an improvement compared to previous quarters. Like I opened, I'm going to mention this in a few minutes, I reopened this submission period until tonight because it seems like it seems that some people had problems like less than 10% but still some had problems submitting last night okay so the assignment submission is reopened until tonight at 11.59 p.m. okay but like obviously for the late submission period so you have a 25% penalty if you submit now late in any case like if you try to submit before 4.12 PM last night. Probably we get some hint on comments that you tried to submit. So for those students who tried to submit before midnight yesterday, those students are probably not going to get the penalty. But this is going to be corrected later by the TAs. But you're going to see the grades first with a penalty. What else? I think that's it. So just a few notes. So on your assignment, don't valid this checker. So have you tested the assignment on OpenLab before? Raise your hand before submitting. If you did, raise your hand. OK, why people did not? Please, seriously, do test on OpenLab, especially if you're using Windows machines. But even if you're using Mac machines, your assignments are going to be like the auto grader is going to be running on OpenLab. If the assignment runs on your machine, and there are going to be a few differences between different operating systems, and we're going to see this in a few classes, for instance, the way that different operating systems do the end of line. So in the end of the line, some operating systems are going to, like Windows and Mac and Linux, they are going to end the lines with different hidden characters, okay? And this affects how your assignment is graded, okay? So one of the common problems, by the way, of many people is that after the read comment, the C comment would fail. And that is natural, because some people were printing the contents of the file, adding an additional line return after they printed the content of the file. So they were adding two line returns, right? And this would bleed into the C comment afterwards, OK? So I've been asking you since the beginning of the quarter, and even if you get zero in this assignment, your grades are not going to be much affected, because assignment 1p1 values, I think, 0.2 or 0.3 on your final grade. Assignment 1p2 values, I think, two points or something like that on your final grade. So if you just get two points of bonus points, You cover even a zero in A1P2, OK? But this is the only assignment that can be fully replaced. The other assignment, you will not be able to recover if you get very low grades in the other assignments. You can recover a little bit, but not fully recover if you get a zero. In this assignment, even if you get a zero, you're fine, OK? Please make sure that your assignments work on OpenLAB before you submit, OK? Just test, just copy your files there, run there, and see if it works, OK? Because the autograder is going to run there, OK? Anyway, so the other thing, yeah, I was just mentioning this a few minutes ago. Some people were printing additional line returns after the R comment was running, right? So I saw that some of TAs actually recommended you to add, if you were using the print comment to print a variable that you would use perhaps a comma and equal nothing, right? To make sure that the print function in Python is not adding this additional line return in the end of itself, okay? Like the world of UTAs recommended this to students, and this was also written in some of the end discussion posts. And this was actually making the other comments fail, because it's a cascade in the autograder, right? It's because the bleeds goes over the other test cases. Good. And yes, I just reopened the late submission period. Good. Just quickly about assignment two. So assignment two is going to be open online after the class today. Assignment two, hopefully, is going to be a little bit fun. Because in assignment two, you are starting to build our future distributed messaging service. So by the end of the quarter, as I promised, you will write your own small client to start messaging, either putting messages on top of a board, like in a Discord-type system, or messaging directly another student from the class as well, through the server. We don't have time to learn how to build the server and the client. You learn how to build a server, but you're not is going to build the server, OK? If you had a semester, there will be the client and the server as well. So since we have a quarter, we are going to be viewed in the client only. Anyway, this assignment, you must invite this assignment here at least two modules. If you believe that it makes sense to break into modern modules, it's up to you, OK? We learned how to build modules last week. You must use input to get user comments, buttons, just like in A1P2. And you will need to use a model that you are going to furnish to you, that's called profile, that will come inside the starter code of the assignment. In any case, you will be completely free to create your own user interface. So you can print whatever command you wish to print, to help the user, to create a menu, the way that you interact with the user, through the normal friendly interface, it's up to you to define. However, it's mandatory that you're going to support one mode that's called admin. So when the user asks you to enter in the admin mode or to respond to comments in the admin mode, there will be essentially no other type of additional hints to the user except what's written on the prompt. mode. And the auto grader is going to run the admin mode of your assignment. The students are also going, the TAs are also going to be running the friendly mode just to take a look if you're creating a good graphical user interface, like in this case text user interface. So little by little you evolve this into like a graphical user interface is by the end of the quarter. And the same type of comment style that you had in A1P1 and A1P2 will be, like, use it in this admin mode. It's going to be normally a letter, then some optional argument, and then some optional additional comments to whatever letter you're running. So run, or read, or create, or delete, and stuff like that. As usual, like, from in all the assignments, like we're evolving a little bit, little by little. So git usage is mandatory. Have it write your simple read me is mandatory. And now, each time more, the way that you style your code, the way that you organize your code, will value a little bit more on your final grade of the assignment. So make sure that you are checking your style, that you are, in this case, decoupling your models in a reasonable way. OK? Like, you're grouping things together that belong together, essentially, OK? Good. And WP2 will be online. I'm going to open, like, already this morning as well. And by the way, I'm going to open not only WP2. I will open WP2 3, 4, and 5 already, OK? They're all going to be open today, as they promised last week. But please, do not even start working the WP's before you finish the assignments, OK? WPs are meant to be fun. But in the same way that they are meant to be fun, if you get a zero in the WPs, but you do some of the bonus points, you recover from your zero in all the WPs. So don't do WPs before you finish the assignments. Good. Any questions about the assignments 1, 2, or WPs? Actually, I have a question. Anyone here use it or try to use the AI helper teach? OK, several. I'm sorry that OpenAI, since there were several users using the system, and we reached the tier one limits of usage of communicating with the API. This is just a week that we need to wait. Our tier is going to increase next week, or later this week. But this OpenAI just stopped responding, because we exchanged the largest amount of tokens that a new user can exchange with the API, for the API. So I'm sorry that it stopped working. I don't know when, yesterday or perhaps Sunday. But a few hours ago, it simply stopped responding. It's not us. It's not UCI that doesn't want to pay. We have a lot of money to pay, but they will not take our money in the way that they organize the access to the API. We're using the latest API. We just reached the limits that we could. This is probably going to be online for WP2 as soon as our access to the API is restored, probably Wednesday or Thursday. And that's going to be open for WP2. And then when WP3 opens, it's going to be open for WP3 as well. So since we could not spend the amount of money that was allocated to us in WP1. So we are going to be able to use, then, the tutor in WP2 and WP3, as well. Good. OK, so as I promised last week, we're going to finish today. File.io, we're going to talk a little bit, then, about how you write CSV files. We're just going to talk a little bit about JSON files, because you're going to be using JSON files in the assignment too. And today, we're also going to be talking about classes. classes. Probably we're going to start today class and we're going to finish inheritance on Thursday, because we have a lot, I think on Friday. Yeah, probably on Friday. Either on Friday or on Monday, on inheritance. And we are going to be talking about classes today and liking inheritance on Thursday. Perhaps we are going to be able to reach inheritance today. Anyway, so Fire.io, then we were last class, we ended the class scene, how you can read CSV files, right? So, but now how you can write them. You also need to know how to write files following the CSV contract, essentially, the CSV format. So to write CSV files in Python, you can use a function that's called writer. You can ask, essentially, the CSV module to run that function called writer, and then you need to pass as an argument a file that you opened. So it's a file that you open on the right mode. So when you open the file that you want to write something to it, you need to open with the right mode. And then you need to set the limiter. So you remember that CSVs, when they're just pure text files, and they are like information separated by commas. Comma is the default one. If you don't specify anything, Python will essentially use commas. But it's always good, it's always a good behavior when you are writing to specify as many things as you can, especially when the file format itself is ambiguous. So like CSV, as we saw last class, 95% of them, 90% of them are going to be commas, but sometimes Excel is going to use a semicolon or something else. So here we are just specifying that the limiter that's going to use is going to use a comma. Then, when for each row you want to write, you are going to write, you are going to create an essential list, and then you are going to call the methods write row of this data writer here. So when we create, when we ask, hey, CSV writer, so CSV, create, please, an object, and then return this to the data writer, essentially. And you pass the arguments, the file that you want to write and the delimiter that you're going to be using. Then for each row of the CSV, you need to essentially pass the information. And the information that is expected is essentially a list. It's a simple Python list with whatever content you want to write to that CSV. So optionally, this is not mandatory, remember. So in CSV files, the header with the titles of each one of the columns is optional. It's not mandatory, OK? So optionally, you are going to write the header. So in this case, we are just writing the header, username, email, and register date. And then you can just call again the write row. So for each row that you want to write again, you are going to pass a new list, OK? And then you pass the information that you want to write to the CSV file as another list with whatever strings you want to write in each one of the records, each one of the fields of your records, essentially. So here, Joe example goes into the username. User1 example is the Mayo. N33 to 2003 is the registered date, and so on and so on. And then just iterate over each one of the roles that you want to write. Then finally, you close the file, and that's it, essentially. So this is my old code example here. It's showing you how you can write a CSV file to the disk containing that information that we were seeing above. So if you want to see in Unix or Mac, or if you're using WSL in Windows, so the Windows subsystem for Linux, if you want to see the contents of any text file, you can use this simple command here that's called cat. So if you type cat and then the name of the file, you're going to see all the prompts of the terminal, you're going to see the contents of the file just printed line-by-line essentially. And here, we're just seeing the content of, after you run this small code, this is the contents that you're going to see in the CSV file. And that's it for CSVs. Anyone has any questions about CSVs? No? OK, good. So CSVs, you're going to be seeing CSVs regularly during your lifetime as programmers. So this is, as I mentioned, one of the most common text formats that you're going to find in industry. The other very important text format that you're going to be finding around, and that we are going to be seeing several times in the next few weeks, is JSON. Raise your hand if you've ever heard anything about JSON before, or if you've ever, okay, good, most of you, right? Raise your hand if you've ever heard anything about REST. Okay, so, okay, we're going to talk about REST again in a few classes. But JSON is one of the standard ways of exchanging information using a protocol called REST. And this protocol that's very famous, called REST, was invented here at UCI, by the way, in the PhD thesis in our department about 20 years ago. Anyway, so JSON stands for JavaScript object notation. So this is like a serialization of JavaScript objects. So serialization means that you're going to get that object from memory and, in a certain way, record in a permanent way somewhere. And JSON was invented to do this, essentially, to write objects from the memory into and to serialize and to store these objects into somewhere. That either is going to be persistent or not persistent. And at least you're going to exchange through some sort of network. So again, JSON was invented in the context of the internet. So it was invented in the context of a standard that's called ECMAScript. So this standard is called ECMAScript. It was defined in the late 90s. And it defines how a certain type of language should be implemented. And the most famous implementation of this standard It's actually called JavaScript. So there's a language that's JavaScript. It is standardized in this standard called ECMAScript. That's standardized how browsers are going to execute that type of code that nowadays is called, by most of you, JavaScript. So JSON was invented as the standard data format for this ECMAScript. And if you want to read the boring specifications of the format, you can just enter in those two links. You have all the specifications, OK? But we are going to see the most important part of the specifications in a few minutes. And even though it started as JavaScript, it's completely language agnostic. It's just a file format, right? So it's a pure text-based standard of writing objects somehow or serializing objects. And nowadays, it's used in essentially all the modern language. And we are going to see a lot of JSON files when we are going to be working with web APIs. So I was talking about REST. So REST is a protocol for you to exchange comments with remote machines using a very simple HTTP type of request. So when we perform a request using one of those APIs, the remote machine will send back to you as a reply, normally, not always, but normally, an object of this type, a JSON object, essentially. And then you need to read these JSON objects and understand what the object contains. In any case, it can, and this is one of the interesting things of JSON objects, remember CSVs, right? CSVs were very rigid in the structure. So, you can essentially only, unless you're using some very weird tricks, using the CSV files, you're storing rectangular arrays, essentially, right? So you have, like, rows and columns, and the number of columns in each row needs to be exactly the same always, right? And this is CSV, right, point. You cannot store, like, more complex objects in a CSV file. In the JSON file, you can store, essentially, any data as long as the data is structured, as long as you have some way to explain, hey, this is how my data is organized. Then you can store in the JSON format. So let's see one example to transform this into something that's a little bit less abstract. So let's see that we have this. So this is the JSON object. So if you just indicate that you're starting the JSON object and closing the JSON object, and then you can just say, hey, the username is joe example, the email is user1 example, and the register date is 03-02-2003. So this is what you call individual members. A JSON object, essentially, is like some way that you're representing your data. OK? And this data can have some members. So it must at least have one member to make sense. But you're going to have members that are going to store in an object. Normally, you're going to have more than one. And the interesting thing here is that members, although they are represented in the file as pure text, so they're represented in the file as a string, you can actually specify what is the type that you're going to have inside the members. So then you can have either strings, numbers, booleans, news, objects. You can have another object as a member of a JSON object. You can create a deep structure, a very deep structure of how your data is organized. And you can also store full arrays or lists inside a JSON object. So in the JSON array, this is an important nomenclature for you. If you have one object, you have a JSON object. If you have multiple objects, you are going to have what you call a JSON array. And what you're seeing here is a JSON array, essentially, with three different objects. Okay? So you have, like, object number one. That's Joe example, Jane example, and the other user as the third object. And in the JSON array, you're always going to separate each one of your objects with commas. each one of your objects with commas. Okay? And here, you're already seeing something that's very important for like a file format when you're using this file format to exchange data, for instance, through an internet connection or through any connection, which is like, you see, there is an indication of the start of the JSON array and of the end of the JSON array, or the start of an object and the end of the object. So, what happens if you start transmitting data in the CSV and suddenly you lost connection after a certain line? Again, the other side doesn't know that there are a thousand lines missing or more, right? So you have no way to keep track that, hey, your file is not yet over, you still have data to send, right? In the JSON format, it's very, like, and it's a part of the format itself. You can always use other additional things on top of the format to check, for instance, what you call checksum, right? But this is not a part of the format. In the JSON format itself, okay, the laser is dead. So in the JSON format itself, we know if there was, like, if you miss it, like the connection will stop it, or the file is corrupted, because the objects, you're going to cut the transmission, for instance, here, and then you open the array, but you never close the array. So the receiving side has some information to say, hey, this file is not complete. So there's something wrong here. I still need more data. So this is something that's very important to keep integrity of the data when you're transmitting over network connections. And you can see, CSV files were created or were invented But before computers were even, like before people were even able to think that computers would talk to each other for some sort of connection, right? Like they were, they predates the Internet like in 20 or 30 years, right? They started to be using together like the machines themselves. JSONs were born already at the age of the Internet, so when they were created, people don't consider that that data would be transmitted over a reliable connection, right? So you have built-in protections, very simple ones, but still, they're built-in in the format itself, OK? Good. So the good and the bad. So the good of JSON files that they are very easy to understand as well. So we can mostly open a JSON file and still be able to understand. Now, they are very easy to create and very easy to read in parts, so anyone can write a simple Python reader, you can write a simple code to read and to write the JSON array from scratch if you need to. It's a little bit more complex than a CSV, but it's still not that cumbersome to write yourself. Again, a good thing is that it's very easy to detect if the file is incomplete, right? Compared to a CSV file. And it can include metadata. So one important thing is that here we have, like, user, email, register date. One thing that you can do in a JSON file is to create an additional JSON object. Because one of the important things, the JSON objects here, they do not need to be exactly the same. Each object that you are adding to this array can be different, right? So you can have an object that actually, it's a meta object. So you can have an object that essentially tells, hey, user name is a string, it may use a string, and the registered date is a date. You need, like, in the person reading this JSON file, you need to parse this meta object. And then when the reader, the software that's reading the file. It's reading the other objects. It already knows what are the different types of the field, of the members that you are defining. So this is something that's very easy to do in a JSON file. But now, the bad things here. So usually, it requires you to read the entire data in memory. So one of the drawbacks of the CSV that was like, OK, You actually can stop the CSV at any row, right? And this is a problem because you never know if you transmitted the entire file or not. It's also one of the advantages of the CSV because you can read each row and process each row without worrying, without bothering about the other rows. In a normal JSON reader, and in the Python implementation of the JSON reader normally, you will read, you will be forced to read the entire JSON array into memory before you do anything with it. And this obviously leads to higher memory occupation in several applications, especially for working with large data sets. But in any case, if you're really working with very large data sets, normally you will work with binary files, not text files. And again, this is also connected. It's highly verbose. So, remember, in a CSV, you just need to write your example, user example, and the date. And then that's it. The entire information for this record is in a single line, right? In the JSON, you need to repeat this, like, dictionary-like structure for each one of your members, for each one of the, like, JSON object from time to your array. You're going to be repeating, like, username, you may register, username, you may register for each one of the objects that were writing the array. So this becomes like highly verbose, and obviously, this will occupy a lot of memory before you compress that data file. So very quickly now, how you're going to be reading and writing data from JSON files in Python. So to read data from a JSON file in Python, using JSON, that comes with the Python standard library. So it just imports JSON. And then you need to open the file that you want to read from. And you open this file with a read, like tech, right? And then you do JSON load this data file here. And after you run this, JSON load will load the entire JSON array into memory, right? It's not like the CSV that you need to read row by row. You read the entire thing in memory. And then, like this data, that's going to be the return of your JSON load is simply going to be a regular Python list. And then you can just either iterate over the Python list or access any element of your Python list, okay? Like this is just an example of printing the entire array or printing the first elements on the first objects of the Python list, okay? And then you get here a simple, like, dictionary-like Python structure that you can access using the names if you wish to, okay? So this is it for reading JSONs in Python. For writing JSONs in Python, so this is not much harder than just reading, you're going to be creating that dictionary-like structures. So each JSON object, as you saw, is essentially additionally like Python structure. So you have the name of the thing and whatever is the content of the thing. So let's suppose that you have this dictionary-like structure here, and this other dictionary-like structure will have username, your example, email, user1example, register date, and whatever register date. So you can create a simple Python list. This is called here the data array. And then you can start appending your dictionary-like structures to this Python array. After you finish creating this, then you can simply, this is just generating an example array. Then, you can write just data by using an example function, how to write this. You open the file now with the write mode, and then you can use a function called dump from the JSON module, so you can just call JSON dump whatever data this function is receiving to the file that you opened in the write mode, and then you can set how many indentation spaces you're going to be using. So the indentation spaces is essentially telling the JSON writer how many spaces you're going to have per indentation level. Normally, you're going to set this to four. And then you close the file after you finish doing whatever you need to do. And if you just run this example, you're going to have this in your text file. So you're writing your JSON array. So one very important thing here. In this line, you are seeing JSON dump calling, like, hey, please, write me this structure that I'm passing to you, like in this array or a list, to this file using the JSON format, essentially. But here, we are actually assigning this to a variable, this JSON object. This variable here is going to be known. So there will be actually known. There is a known type that's going to be returned here, because you're just writing this profile. If you want to return this JSON, if you want to return this contents here into a string that you can call JSON object, you just need to add an S here. So instead of calling dump, you're going to be calling dumps. So essentially dump to a string. And then you're going to create a string in memory with the same contents as this file here. OK, but it's going to become now a string in the memory of your computing, OK? Good. Again, one important thing to remember is that you are going to be using JSON in your assignment too. So just pay attention to what you did today. So we're going to be using this type of things in your assignment too, OK? Okie dokie. So I promise that we will be talking about classes today as well. So classes, then. Who here had any previous experience with classes before? Raise your hand. Quite a bunch of you. OK, good. So a class, then. So when you write code, when you write code inside a computer, you're essentially asking the computer to do stuff, right? But does code exist? Is code something that actually exists in the world? Anyone? Anyone? Do you believe that code exists? Anyone? Does print exist? Or print is a simple abstraction, right? What do you believe? Or what do you feel? Just a feeling. Nobody? OK. So what exists physically? You can think that the CPU of the computer exists, right? But you can go there and knock the CPU of the computer. A book does exist because you can burn the book. The letters in the book, the letters exist. But the letters, they are there simply representing something. The letters, just like the code, they're representing some sort of abstraction that we are making about the word. So when you write a word, or when you write a print, or when you write JSON dumped or import JSON, So this is simply an abstraction for something that you want that physical hardware to do. So essentially, what's going to exist, probably, that's what's the reality. But what's going to exist are the electrodes going around your CPU and making your CPU do something. Everything else is simply an abstraction. And then there are different levels of abstraction that we are going to create to try to make our mind to fit more easily what the computer is doing. Because what we want to do with code is to instruct the CPU or to instruct the computer to do something on our behalf. When you write code, you're essentially trying to communicate with the hardware and ask the hardware, please do that, please do that other thing, please do that other thing. Either the hardware of a single computer computer or the hardware of a very large network of computers that you can call the internet. Everything that you are writing to the computer is essentially an abstraction for something that's going to actually become the reality, which is the electrons flowing there. If you go back in time, a long time ago, you would program computers even before electronic computers mechanically, right? computers mechanically, right? So there was essentially no abstraction. You would, like people would turn knobs inside mechanical calculators for the mechanical calculators to do something. There was essentially no abstraction level between the machine and the human that was operating the machine. So with electronic computers in the beginning people would also connect wires here and there to change the electrical flow. So there was essentially also no abstraction, you would just reconnect the wires, essentially, by hand to reprogram a CPU or to reprogram a computer. And many valve-based computers, before even silicon computers existed, were programmed more or less like that by reconnecting wires, essentially. Afterwards, we had electronic computers. And then we started creating levels and levels of abstraction on top of what electronics electronics was being performed. Just out of curiosity, before computers even existed in the physical sense, and with the first electronic mechanical calculators, there was a person who already essentially predicted and started creating what we now call programming languages, perhaps. That was a woman, by the way, called Ada Lovelace. And she essentially created the first, perhaps, abstract level of programming, or this idea that you can write codes to instruct the machine instead of you doing stuff with the machine. So this evolution of the abstract essentially led to writing software and inventing how software essentially instructs computers to do stuff. So, in the beginning of computers, in the beginning of electronic computers, computers as we know nowadays, like the computers that we're using, the abstractions that were essentially used were abstractions that are very low-level. We would use what we call assembly language, which are essentially translations between zeros and months, or machine codes, into minimonics. So with small texts, like normally using a few letters as possible, that would represent zeros and ones. They would essentially translate into zeros and ones. So the assembler would essentially translate whatever you were writing, using text, into zeros and ones that the machine would execute. So very, very low level programming, essentially. Afterwards, higher and higher level of abstractions on top of this were created. created. So the first abstraction was created things that we call variables, and that you can store values. But the variable actually is just like something that exists in the position in the memory of the computer. But you abstract away the idea that you had to worry about what is the position of the memory of the computer that I'm writing this data to. So we start abstracting a little bit higher in the higher levels. First you came variables, then you started creating functions to group together like of those minimonics. And then you started writing functions. And then you had another abstract level. And then you had language like Fortran, COBOL, appearing, or Lisp, that would abstract and variables and functions, essentially. Afterwards, you had other, even higher level abstractions, where you could build structures that were variables that were grouped together into a big variable-like blob. And this started appearing in other higher level languages, like Algol, algorithmic language, and C, essentially. That's like in the 70s, essentially, that those abstract levels appeared. After that, you can have, like, another abstract level. Like, you're grouping together, essentially, not only, like, variables that perhaps belong together. You also group together functions, and then you can create blobs of things that can represent perhaps functions and variables, and those functions can only operate perhaps on those variables. And you group those things together, and this is essentially what you call a class. And this also started around the 70s and 80s with a language called Smalltalk. also started around the 70s and 80s with a language called Smalltalk. And this idea of grouping things together, like variables and functions together, this idea has to do with what we call modeling. So when we try to write something inside the computer, we are trying to capture some process or we're trying to capture something that exists in the world, even if it's abstract, like a bank account. A bank account doesn't exist physically, right? But it could exist like as a process, something that you can put money into it or withdraw money from it or receive interest from it and whatever, right? So the same thing is abstract in a certain way, right? But it exists in the world in a certain sense. So when we are talking about this, we're talking about modeling something that exists in the world, right? And classes help you model whatever exists in the world to run inside the computer, right? the world to run inside the computer, right? So they essentially are going to variables and those functions that can operate on those variables for you like and this is always the idea to reduce theoretical complexity from whoever is programming the computer right so you don't want to worry about details so you can just worry about what that class exposes to you essentially okay so the idea then of a class is that you're going to create something you're going to write something inside a computer that's going to be used to represent either something or some situation. And then the class itself is going to define with the variables and the functions that you are going to be calling methods now, even if it's a normal function. When that function is inside a class, we call this a method of the class. So the class then is going to define and the behavior and the characteristics of lots of things that may exist of that class. So you can imagine that you can have a car. A car will have certain attributes that are going to be like the mileage, or the size of the fuel tank, or the battery level. And then a car can also do stuff beyond having those qualities, or the core of the car. A car, you can also accelerate a car. The car will drive, or you can brake the car, or you can turn the car to the right or the left. So those are methods that the car can actually have in principle. But essentially, the class will define the behavior and characteristics of the objects. But the class itself is like a blueprint. The class does not exist. exist. exist. You can have the class car, and then you can, what you're going to be seeing the word in a minute, you can create a car. And when you create a car, using this blueprint of what is a car, we instantiate the class. So when you transform that thing that is just a blueprint, it's just a model of something that should exist into actually a variable on your computer. And this is what you call, when you create this variable-like thing, this is called an object. So when you write a class, you're defining the blueprints. When you transform that class, which is a blueprint into something that exists physically in the computer, this is called an object. So we instantiate a class into one object of that class. And you can have multiple objects of a same class inside the software. right? So if you're writing the software for a bank, you can create a class bank account and then you can instantiate for each one of your clients one or more bank accounts, right? bank accounts, right? And those bank accounts are going to be different. They're going to have different values for whatever, like how much money the people have in their bank accounts or how much debt do you have. But each one of those bank accounts will be able to do the same type, most of them are going to be able to do the same type of operations, essentially. Or it is the base ones. So the class then defines the behavior and the characteristics of many objects. And then when you transform these blueprints into something that exists, you instantiate the class into an object. And you may have multiple individual objects. You would have one or more individual objects of a class inside your program. OK? So those things that the objects they are going to have, they are called attributes. So the fuel level in your car is an attribute of your car. The mileage of your car, or the color of your car, or the year that the car is produced, is essentially one attribute. Each one of those are attributes of your car. And the objects as well, they can do stuff. And those actions that they can do stuff, using the function that you're going to be defining inside then, though that is what you call a method. So the methods that you can actually ask the objects to run, essentially. And the methods define the behavior of the class. Let's see one example just to move into a less abstract realm. So this very small code here is possibly be the simplest class that you can write in Python. So we are defining here a class called fruit. And this class does nothing and contains nothing. So this is just passed. So here, you're creating a class that's called fruit. And we're going to see a better class, like with more stuff in a minute. But the important thing here for us to see and for us to remember is that when you're defining classes, you use camel case. And this is how in Python, when you're writing Python code, And you can quickly spot if you're talking about the class in the code. If the class is going to become OK, OK? So as I was mentioning to you, you can create many fruits. Since now we define the class called fruit, we can create some fruit, and then we instantiate the fruit. So when you call this fruit parenthesis, you create a new object or instantiate an object of the class fruit. And this is given the name some fruit, in this case. And then you can obviously print some fruit. And if you print this, or if you run this very, very simple example, you're going to see something like this. So Python is going to tell you, hey, there is a fruit object in this position in the memory. So there's nothing else that you are doing here, because this class has nothing, right? There is nothing inside the class. There is not a method. There are no attributes. There is nothing there, right? So there's not much that you can do with this very simple class. Can you think about some attributes that a fruit should have? Yeah. Yeah, that's a good. Yes. Taste. Yes. Well, taste is a very tricky thing, because anyone here dislikes bananas? Raise your hand. Yeah, see? She dislikes bananas. I like bananas. So taste is fuzzy, right? So taste is something that's going to be probably something that's like, and what you're talking here is modeling. You could create a model where taste would belong to a class, right, where taste would belong to fruit. But like probably a better model would be that a fruit and a human being together would be used to assign a taste. But the fruit itself probably would not have a taste on itself. But perhaps the condition, perhaps you could imagine that the fruit already passed the expiration date. And that's less open to interpretation, essentially. Good, anyway, yes. Yes, so we could add things like the type of the fruit, right? What is a fruit? It's an apple, it's a banana, it's a strawberry, a raspberry, right? A fruit should have a type, essentially, right? And then you could have also a color. You could have like a bullion that would say, hey, do you have seeds or not, right? Is it seedless or not, right? And the condition, you could imagine that you could say if it's ripe or not, for instance. So when we are defining those things, this word is very important for you. When you're defining those attributes, when you're defining the methods or what the class can do, the words that you're going to be using and reading a lot is object modeling. What you're doing is modeling the class. So you're trying to take some abstract thing from the word, or some concrete thing from the word, and abstract into how you're going to represent this inside the computer. So this task is called modeling. We're creating the model of this object. But as I mentioned, until you actually instantiate this class, so while this is just like a class in the computer, there's not a lot that you can do, like this is only an abstract thing, right, it's an abstract entity, then you need to instantiate it, like here we're instantiating a fruit, and we're creating an apple, essentially, okay? So here we are going to instantiate now a fruit, and then we are going to set, so this word is important, we are going to set some attributes, here we are setting the attribute fruit type to apple, then the color to green, and then we are saying that it's not seedless, and then the condition is ripe, okay? And then we can instantiate another fruit. Here we are instantiating a banana. Now we're creating, like, instantiate a new object of the class fruit, and then we start setting the attributes, like banana, brown, and then its seedless false condition is rotten. them. If we just call print again, now we are going to see that Python, yeah. If you just run this small piece of code, we are going to see that Python is also going to print like, hey, we have two fruit objects in different positions of the memory. Again, this is the position of the memory where that object was created. And then you can see that those values are different. So they are in different positions of the memory. So this is string representation. This is the standard way that Python is going to show you or print to you an object if you don't specify how it should print an object. Now we can obviously change a little bit the code, and I'm going to show you in a minute what to do, to tell, hey, Python, when you are called to print an apple or a banana or any object of the class fruit, what you need to do, essentially. So one thing that Python will always going to do is when it's asked to print an object, it will always look inside that class, so inside of the class of that object, for a method called underscore underscore STR underscore underscore. So this underscore underscore STR underscore underscore is essentially the string representation of that object, essentially. OK? So what you're seeing there is we can now define this private method here and tell Python, essentially, hey, the string representation of this class is going to be, like, fruits to points, the condition that it has, then a space, then the color, then another space, then the type of fruit, OK? So, if you want to have, like, a way to print your objects in a friendly way, you should always, inside the class of your objects, define how Python should transform that object into a string, essentially, okay? And then, now, when you call printApple or printBanana, Python will ask, hey, Apple, what's your class? And then Python will get, okay, Apple is a fruit. And then the fruit string representation is this thing here. And then it's going to call this function. And it's going to print whatever it wants to, whatever you want it. Sorry, to the screen. So sorry, this is terrible. So if you just run this code again, you're going to get now fruit ripe green apple, and then fruit rotten brown banana, essentially. OK? Any questions so far? Is it OK? Yeah, OK, good. OK, now I have a question to you. So in the way that we are creating those, the way that we are instantiating those objects, do you believe that something like this makes sense? So can we do, like, apple new fruit, essentially? Apple dot fruit type, apple color, set, is seedless false, and condition is happy. Can an apple be of color set and condition happy? Does that make sense? Yeah, right, it doesn't make sense, right? But Python's not going to prevent you to do this because Python has no idea what's an apple, right? So this is where the modeling comes from, right? So there are lots of ways of doing modeling software. Some ways are better than others, right? What we were doing before is not wrong, But it's just probably a poor modeling, right? Because we were just assigning a variable that was a string that could be any string to the color, or any string to the condition of it, right? So set, again, is not a color. At least it's not a pontoon color. And apple, I think it's not a pontoon color. And apple cannot be happy, essentially, right? So, and when you identify the type of things in the way that you have a class that was defined, this one we call that perhaps your code has a modeling issue. So again, it's not wrong, but you open to the user to use your fruit class to do weird stuff, right? Because in the way that we wrote the fruit class, you could store any string here and there, right? But it doesn't need to be actually a color or a condition. You could store any string. And this, again, can indicate a big modeling issue. So one way to improve this is to do what we call a verification of what the user is trying to set. So when you see a model that was implemented in a certain way and you want to change that model to improve it, normally we call it to review the model. And you're going to be reviewing models several times also in your career. So what better way than, for instance, instead of modeling directly the condition, is to model the age of the fruit. And then this age is an integer, no. And then what you can do is we can define a method that's called get condition. So this get condition is a method that's going to actually check essentially if the fruit is good or not. So here we're defining this get condition that depending on the age of the fruit is going to define if it's ripe or rotten. So depending on the age of the fruit, you're going to get a return that's going to indicate what is the fruit condition, essentially. So this is already a little bit better modeling than simply defining you yourself and forcing, hey, this apple is rotten, or this fruit is rotten. And then in the string representation, now you can change and say, instead of getting directly the condition, you now ask, hey, class, run this code here to check if that fruit that the user defined with a certain age, is it still good or not? So this is an improvement over the modeling that we performed. Obviously, we improved the condition, but we did not improve the color. So the color is still sad. You can still set a set apple that is unripe. And perhaps that's going to be a happy apple when it's ripe. Anyway, how can you then prevent the user from creating completely impossible objects when you create your model, when you're modeling your classes? There is a way to do this, which is to use what you call a constructor. So, you can force almost the user, again, since Python does not have the concept of private, that is a little bit hard, but there is a very big indicator when you use a constructor that you can prevent the user, essentially, from doing very nasty constructs with the object, with the classes, right, to instantiate a very weird object, essentially, like the said apple. So, by using the constructor, we can force and you can verify if the user is setting what we wanted as the conditions for that object to exist correctly, right? So, let's see one example here. So, like a constructor will always be defined in Python using this underscore, underscore, init, underscore, underscore, okay? Then you're going to have the self, which we are going to be talking in a minute, what is the self? And then you can set, okay, that the constructor, when we build a new fruit, we need to tell, hey, this fruit is of a certain type, of a certain color, we need to indicate if it's seedless or not, and we need to indicate its age, okay? So a constructor will always take arguments that the user will need to pass to the class for the class to actually instantiate the object. And then what you can do is essentially when you are building the attributes of that class, so in this case here, we can check, for instance, if the color is not one of the allowed colors to exist, for fruits to exist, right? So you can check, OK, is the user passing one of those, so red, green, blue, yellow, or orange. If it's passing one of those, then it's fine. If it's something else, then it's going to raise an exception, telling the user, hey, you cannot instantiate a fruit of one unknown color. So now, if the user tries to create a set apple, because your code is going to raise the exception, hey, set is essentially not a color, right? So you cannot instantiate a set apple, right? So you can use this type of modeling to essentially protect whoever is writing or using your classes to create incorrect objects, essentially. And normally, when you have an object or when you have a class, when you create a class, when you write a class, you are going to be creating constructors that are going to be as thorough as possible to verify and to make sure that the user is not doing wrong. And the user can be yourself, by the way. If you, after when you wrote your class, after when you instantiate your class, you are the user of the class that you created, right? So the user can be yourself as well. So you can use these constructors to check, to perform any necessary check. Now, for instance, if you try to define a set, Apple, you're going to get an exception raised by the code. So do you know this is because, so in the past four days, I've been going to many dealerships trying to buy a car. And it's terrible. I've been talking like eight hours per day. It's awful. Buying a car in the US is awful. Anyway, so now we cannot create a set fruit anymore. So when then we're doing what you call object-oriented programming, most of your programming is going to be defying classes. So first, you're going to be creating a modeling on your head. After creating the modeling on your head and on paper, you're going to be writing the classes in Python. And then most of the programming will be essentially writing and defining those, instantiating those classes into objects and asking your objects to do things on your behalf. So when you're not doing any object-oriented programming, most of your programming, like essentially all your programming, will be defining variables and asking and functions to run using those variables. When you're doing object-oriented programming, your abstraction level is a little bit higher. So it's not you who are doing stuff. You're asking the class to do stuff on your behalf. Remember that we were asking, for instance, hey, create a CSV writer for me? And then we were asking, hey, CSV writer, write to the file something. So it was not a simple function. on, it was like a method of a class of the CSV writer. It was the CSV writer class that was instantiated into the CSV writer object that we asked it, please write this data to a file. So we were asking the method to do something. And this will happen in Python. In other languages, as I was mentioning, is mall talk or Objective-C. Objective-C is like an older language to do iOS programming programming, and like macOS programming, if you write a little bit lower level code in macOS, you're going to be writing Objective-C. So that other language, instead of you asking the object to do stuff, you're going to be asking the object to pass messages between other objects. And this is what we call a message passing object oriented programming. So in Python, you directly ask the object to do something. OK? So one important thing here. Why do we have all those selves here, here, and here? Like you see, every time that we define a method inside Python, inside a class of Python, we need to define the self. So one important thing that happened in Python is that it's different from other languages. Like, if you program in Java or if you program in other languages, perhaps you're not going to see that type of, like, self, self, self, self. Is that Python actually, when you write those methods, Python doesn't know, the Python object doesn't know the method itself. The Python object only contains the data, but the class contains the methods. And actually Python, the interpreter, needs to ask, hey, class fruit, please, run whatever or the method that is being called onto this object. So when we ask this two lines of code here, so print apple.get condition and print fruit.get condition parentheses apple, what Python interpreter is doing is transforming this line of code into this line of code before running. So even when we believe we created, We instantiated an object of class fruit, and this object is now called apple, right? The apple does not contain the methods. It's the fruit class that contains the methods. So what Python is going to do internally, although you can write this, so Python is just abstracting you this line of code. So Python is actually running, hey fruit class, run the method get condition on the apple object that I'm passing to you. So those two lines of code here are completely equivalent for Python. So Python, the interpreter, doesn't know how to run 32. It simply translates to 33. And that's why all the methods, essentially, needs to know that they are going to receive something. Even if the method depends on nothing, like these get condition methods, does not depend on anything else. Right? There is no parameter that it's going to receive. But you still need to define, hey, you depend on yourself, essentially, on the object that's creating, that's calling, essentially. And that's why you always need to add the self in all the Python methods inside classes. So you're going to be writing this again and again and again. It's going to become automatic. And perhaps in some future version of Python, the self will disappear. because actually it has no actually good reason of existence but at least until now until Python 3 this is what happened in Python okay so line 32 and 33 are completely equivalent and the only line 33 is actually executed by the interpreter okay yeah essentially what Python is going to do is to ask the This is just explaining what's this. So another thing that's extremely important for you to know is class versus instance attributes. So remember that we're talking about attributes. So the classes, they are going to have things like the color of the vehicle or if the apple is seedless or not. Those are the attributes of the class. But you can have attributes of the class and attributes of the instance. So what is the attribute of the class and what is the attribute of the instance? So essentially an attribute of the class, it's essentially an attribute that's going to be the same for all the instances of the class in your code. So when you instantiate a fruit, you can imagine, for instance, the example that you're going to see, that you can have a fruit counter that's just counting how many fruits were instantiated in your code. You can imagine that this class attribute is like a shared global variable between all the instances of that class. So it's something that's going to have the same value, or it's going to point to the same position in the memory, for all the instances of that class in your code. It means meanwhile, the instance attributes and everything that are going to be defined with self dot something, those are going to be things that are going to be only, they're only going to belong to the instance that it's actually been defined. So when you instantiate a class, each class, each object of that class is going to have their own attributes, their own instance attributes. So let's see just the example of, for instance, a fruit counter. So if we define here, like this class fruit, now we have outside any definition. So number of fruits equal to zero. And now we have, and meanwhile we can also have self.fruits, self.color, self.eciduous, self.age. Everything that's created with self.something. We will only belong to the instance that we are creating. For instance, here we can define the number of fruits equal to 0. And then fruit.numberofroots equal to fruit.numberofroots plus 1. So every time that we run a constructor, we are going to update the number of fruits and add 1. So every time that we instantiate, like when you run apple, we create an apple in the code. So if you print how many fruit were created, so if you print this number of fruits from the class fruit, you're going to get how many fruits, essentially, you instantiated. So you can use this, for instance, as the counter for how many things you instantiated officers in class. For instance, if you're creating software for your bank, you can have a counter for how many bank accounts were created, so how many instantiations of the class bank account existed since you created your bank, essentially, since you started running your software. So this is one very simple usage for a class attribute. So again, the important thing for you to remember is that all the instances of the fruit class are going to share the same class attribute, while each one of the instance attributes will be their own. So you can change and modify without worries the instance attributes. But if you modify somehow the class attributes, this is going to be modified for all the copies of all the fruits. And then if you just run this, we're going to see that the counter is going to be 2, because we executed 2 times the constructor, essentially. Yeah, essentially that's it. So one thing that you could do in the weekend or tomorrow, try writing down, just as a self-exercise, then it's very important for you to start thinking about modeling. So just try writing down the paper or in some code if you're used to. Try modeling a few things that could be modeled with classes. So try creating a person, what are the attributes of a person, what are the methods of that a person can have, like a student, a video game character, or a car, essentially. Because next class, for instance, we are going to be seeing inheritance, and we're going to be using, for instance, cars as just a simple example of inheritance as well. The important thing is that when you're trying to model something, you need to try to capture, essentially, what are the relevant characteristics that are going to become the attributes, and what are the relevant actions that whatever you want to capture, they need to do, which are going to become the methods, essentially, the functions that are going to be defined inside your classes. Yes? No, no, no, no, no, no. Like a class is a different thing, because a class is something that can contain methods and functions inside. You can have functions. Those functions are only available to that class, when you instantiate an object of that class, OK? And then not only limited to strings, but you're only limited to information, to the attributes. You cannot have the methods. And the important thing is that having this what we call, by the way, we're going to talk in the next class a little bit, word code encapsulation. What you want to try is to encapsulate inside the class things that can only exist there in that context. You don't want to have vertical leakage. you don't want to have like code for the class that perhaps would could be used in the incorrect way when the functions applied to another type of data type. So we try to encapsulate the methods and the data together into a structure that we call class essentially. Make sense? Good. Any other questions about this? You're going to have labs about classes, and you're going to be working a lot with class in your assignment two as well. And just as a note on classes then on your assignment two, so you're going to be having to work with two classes, not only two, but two major classes in your assignment two. One is going to be what you call the profile class. OK? So the profile class is a very simple way that we started to create to essentially store some sort of user profile. And you're going to be seeing then in the initialization method, so in the constructor of the class, those attributes, those instance attributes. So the DSU server, which is going to be required, the DSU username, so actually the profile username, name, the profile passwords, some short biography, and the list of posts. So the list of posts you're going to be seeing, that's going to be essentially just a list of strings, which are the posts that user profile submitted to the server, essentially. And those are essentially going to be, in the beginning, we're going to be seeing them as the strings, essentially. And they are going to be setting them like this. It's going to be used to store the user profile. And this is going to be self-explanatory, not since I'm in TU, but later, where this is going to be the server that you're going to be using. It's going to have, like, the IP and support, the server that you're going to be using to send the messages to so other students can actually read the message that you're sending to the server. And each instance of the profile will need to have its own list of post objects, essentially. And then you're going also to have another class that's going to call post, right? And this is going to have a list, this is going to be a list of posts, right? And this other class, when you instantiate that class, you're going to create a new post. And this post is going to be, perhaps in the future, sent together with a user ID of another user, and only the user that's where the post was sent to is going to be able to retrieve that post from the server. So a student A wants to send a message to student B, you just need to know the user of the student B, and then you need to link inside your post, not only the string, but also additional information. You're going to be seeing those two classes essentially in your assignment two. And in your assignment two, there will be a starting code that you need to read. And the other skill that you need to gain during the quarter, especially in your assignment file, is that you need to read a lot of code. You're going to receive code, partially documented, partially not documented, that you'll be forced to read, to try to understand what the code is doing, and to actually use that code. So this is going to be, you're going to start seeing this each time more in the future assignments. So let me see if there is anything else here. Yeah, no, so just read over the profile.py code to understand the model and how to use it, OK? So that's it then for today. We are going to be continuing next lecture on the inheritance topic. And a very fun thing, people, people. Next lecture, we are going to start talking about protocols. And these protocols, discussions that are going to be in next class, and next week, We will lead us to start dealing with the web and with remote machines. So you are going to start doing your own servers as well in the future, okay? So thank you very much for your attention and I'm going to be around for a few minutes."}]